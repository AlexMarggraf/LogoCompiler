\section{Comparison With XLogoOnline}
Up to this point, only the three compilers were compared.
It is also interesting to compare the results to xLogoOnline, which does not use a compiler but only an interpreter.
Although this makes a comparison between the compiler for Logo and xLogoOnline more complex since we do not have a compiled time and runtime for xLogo.
In order to make a propper comparison, the time it takes for xLogo to go from the input code to the final picture on the canvas is measured.
For the three compiler, the compile time and the runtime were added since this is also the time it takes form the actual code to the picture on the canvas.
Although this is not a real comparison between the interpreter and compilers, it is still possible to make a fair comparison even though the renderers for our implementation nad xLogo are also taken into account.
In order to keep the results pretty visible, we split the benchmarks up into the simpler and faster benchmarks for the basic functionalities and the longer benchmarks which represent larger programs.
The benchmarks are the same as for the comparison between the compilers and there are also shorter and longer benchmarks.

\subsection{Comparison With XLogoOnline Using Shorter Benchmarks}
At first the behavior for the shorter benchmarks was analyzed since most programs containing only basic functions in Logo are kept pretty short.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{resources/endtoend_smallandmedium}
    \caption{The measurement of the benchmarks for simple programs.}
    \label{fig:endToEndShortMedium}
\end{figure}

Here in\Cref{fig:endToEndShortMedium} it can be obtained that the results for xLogo vary in the measured time for each benchmark and the margin of error is big.
But for simpler tasks, it is obtained that the hard-coded approach is still the slowest of them all with xLogo being the second slowest.
Where an actual difference between the direct approach, the array approach and xLogo cna be seen is for the benchmarks for condition blocks, while loops and for recursions.
For condition blocks, the xLogo is not much slower than the compiler approached but for the recursion, xLogo is significantly slower than all the compiler approaches.
For while loops, xLogo also tends to be faster than the three compiler approaches.
For recursions xLogo is almost five times slower than the complier approaches.
So for most of the shorter benchmarks, in the end it can not be easily said if xLogo or th compilers are faster.\newline

\subsection{Comparison With XLogoOnline Using Longer Benchmarks}

Since for shorter benchmarks both xLogo and the compilers showed similar performance, it is important to check if this behavior is still visible for longer benchmarks.
So in order to analyze this, the longer benchmarks were also run in xLogo.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{resources/endtoend_smallandmedium_Long}
    \caption{The measurement of the long benchmarks for simple programs.}
    \label{fig:endToEndShortMediumLong}
\end{figure}

In\Cref{fig:endToEndShortMediumLong} it can be seen that all approaches are faster than xLogo.
For longer benchmarks, the result is much more clear than for shorter benchmarks.
Here all three compilers are faster than xLogo for all benchmarks.
Here it can be seen that the difference in performance for movement commands and condition blocks is noticeable but not as dominant as for the other benchmarks.
For pen manipulation commands, repeat blocks and while loops, the three compilers are twice as fast as xLogo.
The recursion benchmark was not changed, but it shows the same trend as the other benchmarks.
So it can be said that for small and simpler programs the performance difference between the compilers and xLogo is insignificant but as the programs are becoming larger and more complex,
the compilers are performing better than xLogo.

\subsection{Comparison With XLogoOnline For Complex and Large Programs}

In the following graph\Cref{fig:endtoEndLargeHuge}, the comparison between the three compiler approaches and xLogo for the big picture benchmark and the animation benchmark can be seen.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{resources/endtoend_large_huge}
    \caption{The measurement of the compile time for more complex programs.}
    \label{fig:endtoEndLargeHuge}
\end{figure}

For both benchmarks, it can be seen that the three compilers perform better than xLogo for complex programs, as already seen for the recursion benchmark.
For big pictures, xLogo is about three to four times slower than the compiled versions.
There is also a difference in the time, it takes xLogo to finish the animations compared to the compilers.
It is important to state that the time it takes for the animation to finish is heavily dependent on the time it takes to draw each frame.
Since xLogo takes twice as long as the compilers to finish the animation, it can be said that xLogo takes significantly longer to draw each frame of the animation. \newline \newline

So we can say that for simpler, smaller and shorter programs, containing almost only basics commands, xLogo is as fast or faster than the direct approach and the array approach and in this case xLogo is faster than the hard-coded approach.
But if the programs become larger and more complex like adding while loops, condition blocks or adding animations or recursions,
the performance of the compilers becomes better than xLogo.
So for realistic scenarios and complex programs with many condition blocks, loops, animations and recursions, the three compiler approach become significantly better and superior compared to xLogo.
It should also be noted that for larger repetitions and images the renderer of xLogo starts to become more laggy and stutters as for the compiled version,
the rendered image is still running as smooth as before.
This is also an advantage of the compiled approach with a new renderer.