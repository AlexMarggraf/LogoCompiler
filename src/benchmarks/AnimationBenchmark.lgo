to main
cube
end

to cube
  setsc black
  setpw 2
  
  make "a1 100
  make "a2 100
  make "a3 100
  
  make "b1 -100
  make "b2 100
  make "b3 100
  
  make "c1 -100
  make "c2 -100
  make "c3 100
  
  make "d1 100
  make "d2 -100
  make "d3 100
  
  make "e1 100
  make "e2 100
  make "e3 -100
  
  make "f1 -100
  make "f2 100
  make "f3 -100
  
  make "g1 -100
  make "g2 -100
  make "g3 -100
  
  make "h1 100
  make "h2 -100
  make "h3 -100
  
  make "theta1 0.01 * random 600
  make "theta2 0.01 * random 600
  make "theta3 0.01 * random 600

 make "iter 0
  
  while[:iter<1000][
  
  make :theta1 :theta1 + 0.01
  make :theta2 :theta2 + 0.02
  make :theta3 :theta3 + 0.03
  
  make "co1 cos :theta1
  make "co2 cos :theta2
  make "co3 cos :theta3
  
  make "s1 sin :theta1
  make "s2 sin :theta2
  make "s3 sin :theta3
  
  make "ta1 :co3*:co2*:a1 + (:co3*:s2*:s1 - :s3*:co1)*:a2 + (:co3*:s2*:co1 + :s3*:s1)*:a3
  make "ta2 :s3*:co2*:a1 + (:s3*:s2*:s1 + :co3*:co1)*:a2 + (:s3*:s2*:co1 - :co3*:s1)*:a3
  make "ta3 :co2*:s1*:a2 + :co2*:co1*:a3 - :s2*:a1
  
  make "tb1 :co3*:co2*:b1 + (:co3*:s2*:s1 - :s3*:co1)*:b2 + (:co3*:s2*:co1 + :s3*:s1)*:b3
make "tb2 :s3*:co2*:b1 + (:s3*:s2*:s1 + :co3*:co1)*:b2 + (:s3*:s2*:co1 - :co3*:s1)*:b3
make "tb3 :co2*:s1*:b2 + :co2*:co1*:b3 -(:s2*:b1)

make "tc1 :co3*:co2*:c1 + (:co3*:s2*:s1 - :s3*:co1)*:c2 + (:co3*:s2*:co1 + :s3*:s1)*:c3
make "tc2 :s3*:co2*:c1 + (:s3*:s2*:s1 + :co3*:co1)*:c2 + (:s3*:s2*:co1 - :co3*:s1)*:c3
make "tc3 :co2*:s1*:c2 + :co2*:co1*:c3 -(:s2*:c1)

make "td1 :co3*:co2*:d1 + (:co3*:s2*:s1 - :s3*:co1)*:d2 + (:co3*:s2*:co1 + :s3*:s1)*:d3
make "td2 :s3*:co2*:d1 + (:s3*:s2*:s1 + :co3*:co1)*:d2 + (:s3*:s2*:co1 - :co3*:s1)*:d3
make "td3 :co2*:s1*:d2 + :co2*:co1*:d3 -(:s2*:d1)

make "te1 :co3*:co2*:e1 + (:co3*:s2*:s1 - :s3*:co1)*:e2 + (:co3*:s2*:co1 + :s3*:s1)*:e3
make "te2 :s3*:co2*:e1 + (:s3*:s2*:s1 + :co3*:co1)*:e2 + (:s3*:s2*:co1 - :co3*:s1)*:e3
make "te3 :co2*:s1*:e2 + :co2*:co1*:e3 -(:s2*:e1)

make "tf1 :co3*:co2*:f1 + (:co3*:s2*:s1 - :s3*:co1)*:f2 + (:co3*:s2*:co1 + :s3*:s1)*:f3
make "tf2 :s3*:co2*:f1 + (:s3*:s2*:s1 + :co3*:co1)*:f2 + (:s3*:s2*:co1 - :co3*:s1)*:f3
make "tf3 :co2*:s1*:f2 + :co2*:co1*:f3 -(:s2*:f1)

make "tg1 :co3*:co2*:g1 + (:co3*:s2*:s1 - :s3*:co1)*:g2 + (:co3*:s2*:co1 + :s3*:s1)*:g3
make "tg2 :s3*:co2*:g1 + (:s3*:s2*:s1 + :co3*:co1)*:g2 + (:s3*:s2*:co1 - :co3*:s1)*:g3
make "tg3 :co2*:s1*:g2 + :co2*:co1*:g3 -(:s2*:g1)

make "th1 :co3*:co2*:h1 + (:co3*:s2*:s1 - :s3*:co1)*:h2 + (:co3*:s2*:co1 + :s3*:s1)*:h3
make "th2 :s3*:co2*:h1 + (:s3*:s2*:s1 + :co3*:co1)*:h2 + (:s3*:s2*:co1 - :co3*:s1)*:h3
make "th3 + :co2*:s1*:h2 + :co2*:co1*:h3 -(:s2*:h1)
  
  # which face is in front
  make "showa (:ta3 + :tb3 + :tc3 + :td3)/4
  make "showb (:ta3 + :tb3 + :te3 + :tf3)/4
  make "showc (:tc3 + :tb3 + :tf3 + :tg3)/4
  make "showd (:tc3 + :td3 + :tg3 + :th3)/4
  make "showe (:ta3 + :td3 + :th3 + :te3)/4
  make "showf (:te3 + :tf3 + :tg3 + :th3)/4
  
  make "focal 600
  make "offset -700
  
  make "pa1 (:ta1 * :focal) / (:ta3 + :offset)
  make "pa2 (:ta2 * :focal) / (:ta3 + :offset)
  
  make "pb1 (:tb1 * :focal) / (:tb3 + :offset)
  make "pb2 (:tb2 * :focal) / (:tb3 + :offset)
  
  make "pc1 (:tc1 * :focal) / (:tc3 + :offset)
  make "pc2 (:tc2 * :focal) / (:tc3 + :offset)
  
  make "pd1 (:td1 * :focal) / (:td3 + :offset)
  make "pd2 (:td2 * :focal) / (:td3 + :offset)
  
  make "pe1 (:te1 * :focal) / (:te3 + :offset)
  make "pe2 (:te2 * :focal) / (:te3 + :offset)
  
  make "pf1 (:tf1 * :focal) / (:tf3 + :offset)
  make "pf2 (:tf2 * :focal) / (:tf3 + :offset)
  
  make "pg1 (:tg1 * :focal) / (:tg3 + :offset)
  make "pg2 (:tg2 * :focal) / (:tg3 + :offset)
  
  make "ph1 (:th1 * :focal) / (:th3 + :offset)
  make "ph2 (:th2 * :focal) / (:th3 + :offset)

  make "filter 15
  
  #draw sides
  if(:showa > :filter)[setpc 1 surface :pa1 :pa2 :pb1 :pb2 :pc1 :pc2 :pd1 :pd2]
  if(:showb > :filter)[setpc 2 surface :pa1 :pa2 :pb1 :pb2 :pf1 :pf2 :pe1 :pe2]
  if(:showc > :filter)[setpc 3 surface :pb1 :pb2 :pc1 :pc2 :pg1 :pg2 :pf1 :pf2]
  if(:showd > :filter)[setpc 4 surface :pc1 :pc2 :pd1 :pd2 :ph1 :ph2 :pg1 :pg2]
  if(:showe > :filter)[setpc 5 surface :pd1 :pd2 :pa1 :pa2 :pe1 :pe2 :ph1 :ph2]
  if(:showf > :filter)[setpc 6 surface :pe1 :pe2 :pf1 :pf2 :pg1 :pg2 :ph1 :ph2]
  
  make :iter :iter + 1
  wait 1
  wash
  ]
  
end

to surface :x1 :y1 :x2 :y2 :x3 :y3 :x4 :y4
  home
  tri :x1 :y1 :x2 :y2 :x3 :y3
  home
  tri :x1 :y1 :x3 :y3 :x4 :y4
end

to tri :x1 :y1 :x2 :y2 :x3 :y3

  #vectors between points
  make "ix :x2 - :x1
  make "iy :y2 - :y1
  make "jx :x3 - :x2
  make "jy :y3 - :y2
  make "kx :x1 - :x3
  make "ky :y1 - :y3
  
  #length of vectors
  make "il sqrt(power :ix 2 + power :iy 2)
  make "jl sqrt(power :jx 2 + power :jy 2)
  make "kl sqrt(power :kx 2 + power :ky 2)
  
  #angle between vectors
  make "s 180/pi * arccos (:iy) / (:il)
  make "a1 180/pi * arccos (:ix*:jx + :iy*:jy) / ((:il) * (:jl))
  make "a2 180/pi * arccos (:jx*:kx + :jy*:ky) / ((:jl) * (:kl))
  make "a3 180/pi * arccos (:kx*:ix + :ky*:iy) / ((:kl) * (:il))
  
  setxy :x1 :y1
  
  make "dir 1
  if(:x1 > :x2)[make :dir -1]
  turn :dir :s
  
  #figure out if i need to turn left or right
  #pretty stupid and inefficient
  make :theta (pi/180) * (:dir*:a1)
  
  make "tstx :jx*cos(:theta) - :jy*sin(:theta)
  make "tsty :jx*sin(:theta) + :jy*cos(:theta)
  
  make "cross :ix*:tsty - :iy*:tstx
  
  if(abs :cross > 0.1)[make :dir -1*:dir]
  
  # number of lines filling the triangle
  make "segs 20
  make "rat 1 - (1/:segs)
  
  make "epsi :il - :rat*:il
  make "epsj :jl - :rat*:jl
  make "epsk :kl - :rat*:kl
  
  repeat :segs [
    fd :il
    turn :dir :a1
    fd :jl
    turn :dir :a2
    fd :kl
    turn :dir :a3
    make :il :il - :epsi
    make :jl :jl - :epsj
    make :kl :kl - :epsk
    ]
end

to turn :dir :angle
  if(:dir = 1)[rt :angle][lt :angle]
end